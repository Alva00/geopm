.\"
.\" Copyright (c) 2015, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of Intel Corporation nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.TH "GEOPM_POLICY_C" 3 "2015-10-16" "Intel Corporation" "GEOPM" \" -*- nroff -*-
.SH "NAME"
geopm_policy_c \- geopm mpi job policy management structure
.SH "SYNOPSIS"
.nf
.B #include <geopm_policy.h>
.B #include <geopm_policy_message.h>
.sp
.B Link with -lgeopmpolicy
.sp
.BI "int geopm_policy_create(const char *" "in_config" ,
.BI "                        const char *" "out_config" ,
.BI "                        struct geopm_policy_c **" "policy" );
.sp
.BI "int geopm_policy_destroy(struct geopm_policy_c *" "policy" );
.sp
.BI "int geopm_policy_power(struct geopm_policy_c *" "policy" ,
.BI "                       double " "power_budget" );
.sp
.BI "int geopm_policy_mode(struct geopm_policy_c *" "policy" ,
.BI "                      int " "mode" );
.sp
.BI "int geopm_policy_cpu_freq(struct geopm_policy_c *" "policy" ,
.BI "                          int " "cpu_mhz");
.sp
.BI "int geopm_policy_full_perf(struct geopm_policy_c *" "policy" ,
.BI "                           int " "num_cpu_full_perf");
.sp
.BI "int geopm_policy_tdp_percent(struct geopm_policy_c *" "policy" ,
.BI "                             int " "tdp_percent");
.sp
.BI "int geopm_policy_affinity(struct geopm_policy_c *" "policy" ,
.BI "                          int " "affinity");
.sp
.BI "int geopm_policy_goal(struct geopm_policy_c *" "policy" ,
.BI "                      int " "goal");
.sp
.BI "int geopm_policy_write(const struct geopm_policy_c *" "policy" );
.sp
.BI "int geopm_policy_read(const struct geopm_policy_c *" "policy" );
.sp
.BI "int geopm_policy_enforce_static(const struct geopm_policy_c *" "policy" );
.sp
.BI "int geopm_platform_msr_save(const char *" "path" );
.sp
.BI "int geopm_platform_msr_restore(const char *" "path" );
.sp
.BI "int geopm_platform_msr_whitelist(FILE *" "file_desc" );
.SH "DESCRIPTION"
.PP
The
.I geopmpolicy
library is linked by a system resource manager or parallel job scheduler to
control the global energy policy for each MPI job allocation.  The
geopm_policy_c structure holds the control state for an MPI job and must be
created prior to launching the job.  The interface provided by the policy
interface enables job policy to be enforced statically or dynamically over the
compute application runtime.  This interface can output a MSR whitelist file for
use with the Linux MSR driver. For static policy control, this interface can be
used to create a configuration file that is parsed by the geopm setup or geopm
runtime.  For dynamic control, a daemon can use this interface to create and
modify an interprocess shared memory region on the compute node hosting the
root MPI process of the compute application.  The shared memory region is
monitored by the geopm runtime to enforce policy across the entire MPI job
allocation.  All functions described in this man page return an error code on
failure and zero upon success; see
.B ERRORS
section below for details.
.PP
.BR geopm_policy_create ()
creates
.IR policy ,
an opaque pointer to a geopm_policy_c structure which can create a
configuration file or a shared memory region to control the energy policy for
an MPI job.  If
.I in_config
is not NULL then a configuration file or shared memory region can be read from
when
.I policy
is passed to
.BR geopm_policy_read () .
The string can contain either a config file path or a POSIX shared memory key.
If
.I out_config
is not NULL then a configuration file or shared memory region will be created
and when
.I policy
is passed to
.BR geopm_policy_write ()
the current policy will be written to the region. The string can contain either
a config file path or a POSIX shared memory key.
If both
.I in_config
and
.I out_config
are NULL the creation will fail and an error code is returned.
.PP
.BR geopm_policy_destroy ()
destroys the policy controller referenced by
.I policy
and releases all resources associated with it.
.PP
.BR geopm_policy_power ()
sets the
.IR power_budget ,
in units of Watts, for the
.IR policy .
The power budget determines the upper limit on the aggregate power that can be
drawn by all compute nodes within the entire MPI job allocation.
.PP
.BR geopm_policy_mode ()
selects the control
.I mode
that will be used by the
.IR policy .
The
.I mode
can be selected from the enumeration defined in
.I geopm_policy_message.h
and these options are described in the
.B MODE
section below.
.PP
.BR geopm_policy_cpu_freq ()
sets the
.I cpu_mhz
frequency in MHz to which the
.I policy
will constrain the restricted CPUs.
.PP
.BR geopm_policy_cpu_full_perf ()
sets the number of CPUs,
.I num_cpu_full_perf
which are run unconstrained at full performance for the
.IR policy .
This parameter is used by GEOPM_MODE_FREQ_HYBRID_STATIC AND
GEOPM_MODE_FREQ_HYBRID_DYNAMIC for "big CPUs".
.PP
.BR geopm_policy_tdp_percent ()
sets the percent of Thermal Design Power,
.I tdp_percent
to give restricted CPUs under control under the
.IR policy .
.PP
.BR geopm_policy_affinity ()
sets the
.I affinity
for the
.IR policy .
The affinity is used to place the unrestricted CPUs ("big CPUs") under control
in the GEOPM_MODE_FREQ_HYBRID_STATIC and GEOPM_MODE_FREQ_HYBRID_DYNAMIC modes.
The affinity options are discussed in the
.B AFFINITY
section below.
.PP
.BR geopm_policy_goal ()
sets the
.I goal
for the
.I policy.
The goal affects the behavior of the policy when using dynamic power modes.
.R The goal options are discussed in the
.B GOALS
section below.
.PP
.BR geopm_policy_write ()
writes the state stored in the
.I policy
to a configuration file or shared memory depending on the values passed to
.BR geopm_policy_create ().
.PP
.BR geopm_policy_read ()
reads the state stored in a configuration file or shared memory depending on the values passed to
.BR geopm_policy_create ()
and records the read values to the
.IR policy .
.PP
.BR geopm_platform_msr_save ()
Write the state of all MSR values that
.BR geopm (3)
may modify to a file specified by
.I path
so that they can be restored at a later time.
.PP
.BR geopm_platform_msr_restore ()
Read a set of MSR values from a file specified by
.I path
and set the MSR values of the system to match those given in the file.
.PP
.BR geopm_platform_msr_whitelist ()
Write a MSR whitelist consisting of all MSR offsets and write masks needed
for full operation of geopm power modes. It is intended to be used with the
whitelisting feature of the Linux MSR driver. The whitelist is written out to
.I file_desc
which should be a valid file descriptor.
.PP
.BR geopm_policy_enforce_static ()
enforces the static policy described by the
.I policy
through modifying the system configuration (e.g. setting MSR values).
.SH "STATIC MODES"
The modes listed in this section do not have a run time requirement on geopm.
They are used to enact a power policy that does not require power setting
changes during application runtime.
.TP
.B GEOPM_MODE_TDP_BALANCE_STATIC
The job is statically managed to an aggregate power bound by assigning each
node in the job a static power bound.  Each node is assigned a different power
bound based on the Thermal Design Power of its processor(s). This mode employs
non-uniform power allocation as a means of mitigating load imbalance due to
manufacturing variation and achieves higher average frequencies than
GEOPM_MODE_FREQ_UNIFORM_STATIC or GEOPM_MODE_FREQ_HYBRID_STATIC by leveraging
the RAPL frequency-management technology in Intel processors.
.TP
.B GEOPM_MODE_FREQ_UNIFORM_STATIC
All nodes in the job run at a uniform static frequency. The job is not managed
to an aggregate power bound. This mode is intended to address static load
imbalance due to manufacturing variation among processors in the system and
does so by letting the nodes consume whatever power they need to in order to
achieve the designated frequency.
.TP
.B GEOPM_MODE_FREQ_HYBRID_STATIC
Similar to the GEOPM_MODE_FREQ_UNIFORM_STATIC mode except that it accelerates
any "big CPUs" designated to run the serial portion of the application.  This
mode is intended to address static load imbalance due to manufacturing
variation while mitigating application scaling challenges. Serial CPUs always
run at max frequency while the parallel "little CPUs" run at the specified
uniform static frequency. The job is not managed to an aggregate power bound.
.SH DYNAMIC MODES
The modes listed in this section are used to dynamically adapt power policy
during application runtime and have a run time requirement on geopm. In these
advanced modes,
.BR geopm (3)
dynamically manages the job to an aggregate power bound while redistributing
power among the nodes to equalize performance or frequency across nodes,
depending on the mode.
.TP
.B GEOPM_MODE_PERF_BALANCE_DYNAMIC
In this mode,
.BR geopm (3)
dynamically manages the job to an aggregate power bound while leveraging
global application awareness to maximize application performance. The geopm
runtime tracks the application’s critical path and continually redistributes
power to steer power to the nodes on the critical path and enable them to run
at higher performance (if possible); node frequencies and power allocation are
strategically non-uniform.  By focusing on the critical path, this mode
addresses multiple forms of load imbalance and is agnostic to the source of
the load imbalance. This mode achieves the highest performance of all of the
power modes.
.TP
.B GEOPM_MODE_FREQ_UNIFORM_DYNAMIC
Similar to the GEOPM_MODE_FREQ_UNIFORM_STATIC mode except that node
frequencies are changed over time uniformly across the job allocation and the
job is managed to an aggregate power bound. This mode applies non-uniform
power bounds on the nodes as a means of throttling them to the maximum common
frequency that does not exceed the job’s aggregate power bound. Power is
dynamically reallocated among nodes to use up all available power for the job
(if possible) and equalize the frequency variation across processors that is
exposed when running under a given power bound. This mode achieves higher
performance than the FREQ_UNIFORM_STATIC mode.
.TP
.B GEOPM_MODE_FREQ_HYBRID_DYNAMIC
Similar to the GEOPM_MODE_FREQ_HYBRID_STATIC mode except that the constrained
"little CPU" frequencies are the only ones whose frequencies are changed over
time. The "big CPUs" in each node run at maximum frequency. The "little CPUs"
in each node are throttled to the maximum common frequency that does not
result in exceeding the job’s aggregate power bound. This mode is intended to
address load imbalance due to manufacturing variation while mitigating
application scaling challenges. This mode achieves higher performance than the
FREQ_HYBRID_STATIC mode.
.SH "GOALS"
.TP
.B GEOPM_FLAGS_GOAL_CPU_EFFICIENCY
Set energy policy to maximize CPU efficiency, not performance (not yet
implemented).
.TP
.B GEOPM_FLAGS_GOAL_NETWORK_EFFICIENCY
Set energy policy to maximize network efficiency, not performance (not yet
implemented).
.TP
.B GEOPM_FLAGS_GOAL_MEMORY_EFFICIENCY
Set energy policy to maximize memory efficiency, not performance (not yet
implemented).
.SH "AFFINITY"
.TP
.B GEOPM_FLAGS_BIG_CPU_TOPOLOGY_COMPACT
The "small CPUs" are located nearby each other on the processor package.
This should match the openmp runtime environment.
.TP
.B GEOPM_FLAGS_BIG_CPU_TOPOLOGY_SCATTER
The "small CPUs" are located as far from each other as possible across the
processor package.  This should match the openmp runtime environment.
.SH "ERRORS"
All functions described on this man page return an error code.  See
.BR geopm_error (3)
for a full description of the error numbers and how to convert them to
strings.
.SH "COPYRIGHT"
Copyright (C) 2015 Intel Corporation. All rights reserved.
.SH "SEE ALSO"
.BR geopm (3),
.BR geopm_ctl_c (3),
.BR geopm_error (3),
.BR geopm_omp (3),
.BR geopm_prof_c (3),
.BR geopm_version (3),
.BR geopmctl (3),
.BR geopmkey (3),
.BR geopmpolicy (3)
