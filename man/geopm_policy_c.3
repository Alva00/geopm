.\"
.\" Copyright (c) 2015, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of Intel Corporation nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.TH "GEOPM_POLICY_C" 3 "2015-08-30" "Intel Corporation" "GEOPM_POLICY_C" \" -*- nroff -*-
.SH "NAME"
geopm_policy_c \- geopm mpi job policy management structure
.SH "SYNOPSIS"
.nf
.B #include <geopm_policy.h>
.B #include <geopm_policy_message.h>
.sp
.B Link with -lgeopmpolicy
.sp
.BI "int geopm_policy_create(const char *" "config_path" ,
.BI "                        const char *" "shm_key" ,
.BI "                        struct geopm_policy_c **" "policy" );
.sp
.BI "int geopm_policy_destroy(struct geopm_policy_c *" "policy" );
.sp
.BI "int geopm_policy_power(struct geopm_policy_c *" "policy" ,
.BI "                       double " "power_budget" );
.sp
.BI "int geopm_policy_mode(struct geopm_policy_c *" "policy" ,
.BI "                      int " "mode" );
.sp
.BI "int geopm_policy_flags(struct geopm_policy_c *" "policy" ,
.BI "                       unsigned long " "flags" );
.sp
.BI "int geopm_policy_write(const struct geopm_policy_c *" "policy" );
.sp
.B "HELPER FUNCTIONS:"
.br
.BI "int geopm_cpu_freq_flags_update(int " "cpu_mhz" ,
.BI "                                int " "num_cpu_full_perf" ,
.BI "                                unsigned long *" "flags" );
.sp
.BI "int geopm_tdp_percent_flags_update(int " "percent_tdp" ,
.BI "                                   unsigned long *" "flags" );
.sp
.SH "DESCRIPTION"
.PP
The
.I geopmpolicy
library is linked by a system resource manager or parallel job scheduler to
control the global energy policy for each MPI job allocation.  The
geopm_policy_c structure holds the control state for an MPI job and must be
created prior to launching the job.  The interface provided by the policy
interface enables job policy to be enforced statically or dynamically over the
compute application runtime.  For static policy control, this interface can be
used to create a configuration file that is parsed by the geopm setup or geopm
runtime.  For dynamic control, a daemon can use this interface to create and
modify an interprocess shared memory region on the compute node hosting the
root MPI process of the compute application.  The shared memory region is
monitored by the geopm runtime to enforce policy across the entire MPI job
allocation.  All functions described in this man page return an error code on
failure and zero upon success; see
.B ERRORS
section below for details.
.PP
.BR geopm_policy_create ()
creates
.IR policy ,
an opaque pointer to a geopm_policy_c structure which can create a
configuration file or a shared memory region to control the energy policy for
an MPI job.  If
.I config_path
is not NULL then a configuration file will be produced when the
.I policy
is passed to
.BR geopm_policy_write ().
If
.I shm_key
is not NULL then a shared memory region will be created and when
.I policy
is passed to
.BR geopm_policy_write ()
the current policy will be written to the region.
If both
.I config_path
and
.I policy
are non-NULL the creation will fail and an error code is returned.
.PP
.BR geopm_policy_destroy ()
destroys the policy controller referenced by
.I policy
and releases all resources associated with it.
.PP
.BR geopm_policy_power ()
sets the
.IR power_budget ,
in units of Watts, for the
.IR policy .
The power budget determines the upper limit on the aggregate power that can be
drawn by all compute nodes within the entire MPI job allocation.
.PP
.BR geopm_policy_mode ()
selects the control
.I mode
that will be used by the
.IR policy .
The
.I mode
can be selected from the enumeration defined in
.I geopm_policy_message.h
and these options are described in the
.B MODE
section below.
.PP
.BR geopm_policy_flags ()
sets the mode
.I flags
for the
.I policy
which can be used to augment the behavior of a control mode.  The flags are
enumerated in the
.I geopm_policy_message.h
header and described in the
.B FLAGS
section below.  The flags can be combined with the bitwise OR operator, and
some flags may be silently ignored by some modes.
.PP
.BR geopm_policy_write ()
writes the state stored in the
.I policy
to a configuration file or
shared memory depending on the values passed to
.BR geopm_policy_create ().
.sp
.B "HELPER FUNCTIONS:"
.br
.PP
.BR geopm_cpu_freq_flags_update ()
is used to update the
.I flags
to configure the uniform frequency control modes.  The input
.I cpu_mhz
gives the CPU frequency in units of MHz to which the restricted CPUs are
contrained.  The input
.I num_cpu_full_perf
value determines the number of CPUs which are run unconstrained at full
performance (used by GEOPM_MODE_FREQ_HYBRID_STATIC AND
GEOPM_MODE_FREQ_HYBRID_DYNAMIC for "big CPUs").  Note that this function
modifies only the bits in
.I flags
which control these features; other bits in
.I flags
are unmodified by this function.
.PP
.BR geopm_tdp_percent_flags_update ()
is used to update the
.I flags
to configure the percent of Thermal Design Power to restricted CPUs under
control.
.SH "STATIC MODES"
The modes listed in this section do not have a run time requirement on geopm.
They are used to enact a power policy that does not require power setting
changes during application runtime.
.TP
.B GEOPM_MODE_TDP_BALANCE_STATIC
The job is statically managed to an aggregate power bound by assigning each
node in the job a static power bound.  Each node is assigned a different power
bound based on the Thermal Design Power of its processor(s). This mode employs
non-uniform power allocation as a means of mitigating load imbalance due to
manufacturing variation and achieves higher average frequencies than
GEOPM_MODE_FREQ_UNIFORM_STATIC or GEOPM_MODE_FREQ_HYBRID_STATIC by leveraging
the RAPL frequency-management technology in Intel processors.
.TP
.B GEOPM_MODE_FREQ_UNIFORM_STATIC
All nodes in the job run at a uniform static frequency. The job is not managed
to an aggregate power bound. This mode is intended to address static load
imbalance due to manufacturing variation among processors in the system and
does so by letting the nodes consume whatever power they need to in order to
achieve the designated frequency.
.TP
.B GEOPM_MODE_FREQ_HYBRID_STATIC
Similar to the GEOPM_MODE_FREQ_UNIFORM_STATIC mode except that it accelerates
any "big CPUs" designated to run the serial portion of the application.  This
mode is intended to address static load imbalance due to manufacturing
variation while mitigating application scaling challenges. Serial CPUs always
run at max frequency while the parallel "little CPUs" run at the specified
uniform static frequency. The job is not managed to an aggregate power bound.
.SH DYNAMIC MODES
The modes listed in this section are used to dynamically adapt power policy
during application runtime and have a run time requirement on geopm. In these
advanced modes,
.BR geopm (3)
dynamically manages the job to an aggregate power bound while redistributing
power among the nodes to equalize performance or frequency across nodes,
depending on the mode.
.TP
.B GEOPM_MODE_PERF_BALANCE_DYNAMIC
In this mode,
.BR geopm (3)
dynamically manages the job to an aggregate power bound while leveraging
global application awareness to maximize application performance. The geopm
runtime tracks the application’s critical path and continually redistributes
power to steer power to the nodes on the critical path and enable them to run
at higher performance (if possible); node frequencies and power allocation are
strategically non-uniform.  By focusing on the critical path, this mode
addresses multiple forms of load imbalance and is agnostic to the source of
the load imbalance. This mode achieves the highest performance of all of the
power modes.
.TP
.B GEOPM_MODE_FREQ_UNIFORM_DYNAMIC
Similar to the GEOPM_MODE_FREQ_UNIFORM_STATIC mode except that node
frequencies are changed over time uniformly across the job allocation and the
job is managed to an aggregate power bound. This mode applies non-uniform
power bounds on the nodes as a means of throttling them to the maximum common
frequency that does not exceed the job’s aggregate power bound. Power is
dynamically reallocated among nodes to use up all available power for the job
(if possible) and equalize the frequency variation across processors that is
exposed when running under a given power bound. This mode achieves higher
performance than the FREQ_UNIFORM_STATIC mode.
.TP
.B GEOPM_MODE_FREQ_HYBRID_DYNAMIC
Similar to the GEOPM_MODE_FREQ_HYBRID_STATIC mode except that the constrained
"little CPU" frequencies are the only ones whose frequencies are changed over
time. The "big CPUs" in each node run at maximum frequency. The "little CPUs"
in each node are throttled to the maximum common frequency that does not
result in exceeding the job’s aggregate power bound. This mode is intended to
address load imbalance due to manufacturing variation while mitigating
application scaling challenges. This mode achieves higher performance than the
FREQ_HYBRID_STATIC mode.
.SH "FLAGS"
.TP
.B GEOPM_FLAGS_GOAL_CPU_EFFICIENCY
Set energy policy to maximize CPU efficiency, not performance (not yet
implemented).
.TP
.B GEOPM_FLAGS_GOAL_NETWORK_EFFICIENCY
Set energy policy to maximize network efficiency, not performance (not yet
implemented).
.TP
.B GEOPM_FLAGS_GOAL_MEMORY_EFFICIENCY
Set energy policy to maximize memory efficiency, not performance (not yet
implemented).
.TP
.B GEOPM_FLAGS_BIG_CPU_TOPOLOGY_COMPACT
The "big CPUs" are located nearby each other on the processor package.
.TP
.B GEOPM_FLAGS_BIG_CPU_TOPOLOGY_SCATTER
The "big CPUs" are located as far from each other as possible across the
processor package.
.SH "ERRORS"
All functions described on this man page return an error code.  See
.BR geopm_error_e (3)
for a full description of the error numbers and how to convert them to
strings.
.SH "COPYRIGHT"
Copyright (C) 2015 Intel Corporation. All rights reserved.
.SH "SEE ALSO"
.BR geopm (3),
.BR geopm_ctl_c (3),
.BR geopm_prof_c (3),
.BR geopm_error_e (3),
.BR geopm_version (3),
.BR geopmctl (3),
.BR geopmkey (3),
.BR geopmpolicy (3)
