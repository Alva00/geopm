geopm_prof_c(3) -- geopm application profiling structure
========================================================

[//]: # (Copyright (c) 2015, 2016, Intel Corporation)
[//]: # ()
[//]: # (Redistribution and use in source and binary forms, with or without)
[//]: # (modification, are permitted provided that the following conditions)
[//]: # (are met:)
[//]: # ()
[//]: # (    * Redistributions of source code must retain the above copyright)
[//]: # (      notice, this list of conditions and the following disclaimer.)
[//]: # ()
[//]: # (    * Redistributions in binary form must reproduce the above copyright)
[//]: # (      notice, this list of conditions and the following disclaimer in)
[//]: # (      the documentation and/or other materials provided with the)
[//]: # (      distribution.)
[//]: # ()
[//]: # (    * Neither the name of Intel Corporation nor the names of its)
[//]: # (      contributors may be used to endorse or promote products derived)
[//]: # (      from this software without specific prior written permission.)
[//]: # ()
[//]: # (THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS)
[//]: # ("AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT)
[//]: # (LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR)
[//]: # (A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT)
[//]: # (OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,)
[//]: # (SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT)
[//]: # (LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,)
[//]: # (DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY)
[//]: # (THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT)
[//]: # ((INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE)
[//]: # (OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.)

## SYNOPSIS

**\#include [<geopm.h>](https://github.com/geopm/geopm/blob/dev/src/geopm.h)**

`Link with -lgeopm`

  * `int geopm_prof_create(`:
    `const char *`_name_, <br>
    `const char *`_shm_key_, <br>
    `MPI_Comm` _comm_, <br>
    `struct geopm_prof_c **`_prof_);

  * `int geopm_prof_destroy(`:
    `struct geopm_prof_c *`_prof_);

  * `int geopm_prof_default(`:
    `struct geopm_prof_c *`_prof_);

  * `int geopm_prof_region(`:
    `struct geopm_prof_c *`_prof_, <br>
    `const char *`_region_name_, <br>
    `long` _policy_hint_, <br>
    `uint64_t *`_region_id_);

  * `int geopm_prof_enter(`:
    `struct geopm_prof_c *`_prof_, <br>
    `uint64_t` _region_id_);

  * `int geopm_prof_exit(`:
    `struct geopm_prof_c *`_prof_, <br>
    `uint64_t` _region_id_);

  * `int geopm_prof_progress(`:
    `struct geopm_prof_c *`_prof_, <br>
    `uint64_t` _region_id_, <br>
    `double` _fraction_);

  * `int geopm_prof_outer_sync(`:
    `struct geopm_prof_c *`_prof_);

  * `int geopm_prof_disable(`:
    `struct geopm_prof_c *`_prof_, <br>
    `const char *`_feature_name_);

  * `int geopm_prof_print(`:
    `struct geopm_prof_c *`_prof_, <br>
    `const char *`_file_name_, <br>
    `int` _depth_);

  * `int geopm_tprof_create(`:
    `int` _num_thread_, <br>
    `size_t` _num_iter_, <br>
    `size_t` _chunk_size_, <br>
    `struct geopm_tprof_c **`_tprof_);

  * `int geopm_tprof_destroy(`:
    `struct geopm_tprof_c *`_tprof_);

  * `int geopm_tprof_increment(`:
    `struct geopm_tprof_c *`_tprof_, <br>
    `struct geopm_prof_c *`_prof_, <br>
    `uint64_t` _region_id_, <br>
    `int` _thread_idx_);

## DESCRIPTION
The geopm_prof_c and geopm_tprof_c structures enable application
profiling for geopm.  The functions associated with he geopm_prof_c
and geopm_tprof_c structures are described here.  These functions
enable application feedback to the control algorithm for identifying
regions of code, progress within regions, and global synchronization
points in the application.  Regions of code define periods in the
application during which control parameters are tuned with the
expectation that control parameters for a region can be optimized
independently of other regions.  In this way a region is associated
with a set of control parameters which can be optimized, and future
time intervals associated with the same region will benefit from the
application of control parameters which were determined from tuning
within previous occurrences of the region.  There are two competing
motivations for defining a region within the application.  The first
is to identify a section of code that has distinct compute, memory or
network characteristics.  The second is to avoid defining these
regions such that they are nested within each other, as nested regions
are ignored, and only the outer most region is used for tuning when
nesting occurs.  Identifying progress within a region can be used to
alleviate load imbalance in the application under the assumption that
the region is bulk synchronous.  Under the assumption that the
application employs an iterative algorithm which synchronizes
periodically the user can alleviate load imbalance on larger time
scales than the regions provide.  This is done by marking the end of
the outer most loop, or the "outer synchronization point."

  * `geopm_prof_create`():
    creates a profile object, _prof_, which can be used in conjunction
    with all the other `geopm_prof_*`() APIs described here.  The
    resources associated with the _prof_ are released by passing it to
    `geopm_prof_destroy`().  The first profile object to be created is
    stored as the default, and if a NULL pointer is subsequently
    passed as the profile argument to any of the `geopm_prof_*`()
    APIs, this default object will be used.  See
    `geopm_prof_default`() for more information about the default
    profile.  Construction requires a _name_ which is displayed when
    the profile is printed.  The _shm_key_ specifies the base of the
    POSIX shared memory key that is used to comminicate with the
    control process on the node.  It must start with the '/' character
    and have no other occurances of the '/'.  If no key is provided
    (NULL or empty string), then the environment is queried for
    GEOPM_SHMKEY (see `geopm`(7) for description of environment
    variables) and if set this value is used, otherwise the default
    key '/geopm-default' is used.  The _comm_ is an MPI communicator
    that the calling MPI application is running on (probably
    MPI_COMM_WORLD).

  * `geopm_prof_destroy`():
    releases all resources associated with the _prof_ object.

  * `geopm_prof_default`():
    sets the default profile object to _prof_.  If NULL is passed for
    _prof_ then the return code indicates if there is currently a
    default profile object: returns zero if a default profile object
    has been set and GEOPM_ERROR_LOGIC if it has not been set.  The
    default profile object will be used if NULL is passed for _prof_
    for any of the `geopm_prof_*`() APIs.

  * `geopm_prof_region`():
    registers an application region with the profile object _prof_.
    The _region_name_ and _policy_hint_ are input parameters, and the
    _region_id_ is output.  The _region_id_ can be used with
    `geopm_prof_enter`(), `geopm_prof_exit`(),
    `geopm_prof_progress`(), and `geopm_tprof_progress`() to
    referrence the region.  If the region name has been previously
    registered, a call to this function will set the _region_id_ but
    the state in the _prof_ structure associated with the region is
    unmodified.  The _region_name_ is used to determine the output
    _region_id_ and is also displayed in the profiling report to
    identify the region.  The _policy_hint_ is one of the values given
    by the geopm_prof_hint_e enum defined in _geopm_policy.h_ which
    determines the initial control settings.  The following hints are
    supported: `GEOPM_POLICY_HINT_UNKNOWN`,
    `GEOPM_POLICY_HINT_COMPUTE`, `GEOPM_POLICY_HINT_MEMORY`,
    `GEOPM_POLICY_HINT_NETWORK`.

  * `geopm_prof_enter`():
    is called by the compute application to mark the beginning of the
    profiled compute region associated with the _region_id_. If this
    call is made after entering a different region, but before exiting
    that region, the call is ignored and an error code is returned
    (i.e. nested regions are ignored).

  * `geopm_prof_exit`():
    is called by the compute application to mark the end of a compute
    region.  If this region is nested then the call is ignored and an
    error code is returned.

  * `geopm_prof_progress`():
    is called by compute application in single threaded context to
    signal the fractional progress, _fraction_ through the work
    required to complete the region where _fraction_ is between 0 and 1.
    If the _region_id_ does not match the _region_id_ of the last
    call to geopm_prof_prof_enter() which was not nested, then this
    call is ignored and an error code is returned.

  * `geopm_prof_outer_sync`():
    is called just prior to the highest level global synchronization
    point in an application.  This occurs in the application's
    outermost loop in an iterative algorithm just prior to the last
    synchronizing MPI call.  There should be just one place in an
    application code where this call occurs, and it should be called
    repeatedly inside of a loop.

  * `geopm_prof_disable`():
    is called at application start up to disable a profiling feature.
    By default all profiling features available on the system are
    enabled.  The set of all possible values for _feature_name_ are:
    "instr", "flop", and "joules".  This API is not currently
    implemented.

  * `geopm_prof_print`():
    writes a profile report to the file named _file_name_ based on the
    data collected so far.  This is intended for use just prior to
    application termination, and the _prof_ object is not valid after
    calling `geopm_prof_print`(), though it should still be destroyed
    by calling `geopm_prof_destroy`().  All profile information above
    the specified _depth_ in the control tree hierarchy is contained
    in the report.  A depth of 0 gives only statistics aggregated over
    all MPI processes.  The _depth_ parameter is not currently used
    and the current implementation creates one report file per compute
    node.

  * `geopm_tprof_create`():
    creates a thread profiling object, _tprof_, which extends the
    functionality of a `geopm_prof_c` object to report progess within
    threaded regions.  The interface assumes a fixed number of
    threads, _num_thread_, which are performing work sharing on a list
    of tasks _num_iter_ long (e.g. an omp parallel for loop with
    _num_iter_ loops).  In the specific case of an OpenMP for loop
    statically scheduled with a chunk size then the _chunk_size_
    arguement can be specified to be non-zero and the work
    distribution amung threads is explicitly calculated while the
    minimum progress of any thread is reported.  In all other
    threading models _chunk_size_ should be specified to be zero and
    progress is aggregated and the mean progress is reported.

  * `geopm_tprof_destroy`():
    releases all resources associated witht the _tprof_ object.  The
    _tprof_ object should be created and destroyed for each process
    entry into a thread parallel region: the _tprof_ object cannot be
    reused.

  * `geopm_tprof_increment`():
    is called after a thread has completed each work unit to report
    progress.  The _tprof_ thread profiling object and _prof_ general
    profiling object are passed as the first two arguments. Passing
    NULL for _prof_ inferrs the default profile object.  The region
    identifier returned by `geopm_prof_region`() is passed as the
    third argument, _region_id_.  The last argument is the thread
    index which is in the range of [0, 1, ..., _num_thread_ - 1] where
    _num_thread_ is the parameter passed when the _tprof_ was created.
    This index uniquely identifies the thread that is reporting
    progress.  When using the `geopm_tprof_increment`()
    interface to report progress, it is incorrect to also call the
    `geopm_prof_progress`() interface.

## EXAMPLE

    #include <stdlib.h>
    #include <string.h>
    #include <errno.h>
    #include <stdint.h>
    #include <mpi.h>
    #include <omp.h>

    #include "geopm.h"


    int main(int argc, char **argv)
    {
        int chunk_size = 0;
        int err = 0;
        int index = 0;
        int rank = 0;
        int num_iter = 100000000;
        double sum = 0.0;
        struct geopm_prof_c *prof = NULL;
        struct geopm_tprof_c *tprof = NULL;
        int num_thread = 0;
        int thread_idx = 0 ;
        uint64_t region_id = 0;

        err = MPI_Init(&argc, &argv);
        if (!err) {
    #pragma omp parallel
    {
            num_thread = omp_get_num_threads();
    }
            chunk_size = num_iter / num_thread;
            if (num_iter % num_thread) {
                ++chunk_size;
            }
            err = geopm_tprof_create(num_thread, num_iter, chunk_size, &tprof);
        }
        if (!err) {
            err = geopm_prof_create("timed_loop", NULL, MPI_COMM_WORLD, &prof);
        }
        if (!err) {
            err = geopm_prof_region(NULL, "loop_0", GEOPM_POLICY_HINT_UNKNOWN, &region_id);
        }
        MPI_Barrier(MPI_COMM_WORLD);
        if (!err) {
            err = geopm_prof_enter(NULL, region_id);
        }
        if (!err) {
    #pragma omp parallel default(shared) private(thread_idx, index)
    {
            thread_idx = omp_get_thread_num();
    #pragma omp for reduction(+:sum) schedule(static, chunk_size)
            for (index = 0; index < num_iter; ++index) {
                sum += (double)index;
                geopm_tprof_increment(tprof, prof, region_id, thread_idx);
            }
    }
            err = geopm_prof_exit(NULL, region_id);
        }
        if (!err) {
            err = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        }
        if (!err && !rank) {
            printf("sum = %e\n\n", sum);
        }
        if (!err) {
            err = geopm_prof_print(prof, "timed_loop", 0);
        }
        if (!err) {
            err = geopm_prof_destroy(prof);
        }

        int tmp_err = MPI_Finalize();

        return err ? err : tmp_err;
    }

## ERRORS
All functions described on this man page return an error code.  See
**geopm_error(3)** for a full description of the error numbers and how
to convert them to strings.

## COPYRIGHT
Copyright (C) 2015, 2016, Intel Corporation. All rights reserved.

## SEE ALSO
**geopm(7)**,
**geopm_comm(3)**,
**geopm_ctl_c(3)**,
**geopm_error(3)**,
**geopm_fortran(3)**,
**geopm_omp(3)**,
**geopm_policy_c(3)**,
**geopmkey(1)**,
**geopm_version(3)**,
**geopmctl(1)**,
**geopmpolicy(1)**
